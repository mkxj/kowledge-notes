准备阶段
1.spa和mpa
	1)spa：一个外壳页面和多个页面片段构成 页面片段刷新 在一个页面上，传递数据较为简单
	2)mpa: 多个页面构成，不需重新加载，跳转后公共资源要重新加载，整页刷新 数据传递：依赖cookies和localstroge和URL，实现麻烦，加载慢，不流畅，用户体验差

2.模块间的通信方法
	1）通过路由带参数进行传值 如组件A可以通过query把值传给组件B
	2）通过设置session storage缓存的形式进行传递 A组件设置缓存B组件获取到A设置的缓存
	3）父子组件：父组件通过props向子组件传数据。子组件通过$emit事件向父组件传递
	4）不同组件：中央事件总线的方法 bus(定义一个专门的vue实例，并导出)bus.$emit  bus.$on bus.$off注意使用时的this区别bus的vue实例和该项目的vue实例
	5）不同组件：vuex(大型单页面应用)专为vue开发的状态管理模式(state, Getter, Mutation, Action, Module)
	vuex状态存储是响应式的，所以用状态在计算属性里用，触发状态变化是在 methods 中提交 mutation
	简单说通过action处理数据，然后通过mutation 把处理后(state)中,要用就通过getter从(state)中取。

3.html, jade(pug)
	1)jade: 可移植性差,调试困难,性能不出色,不过可以加快开发效率 a: img表示内联式=> <a><img/></a>
	分三种：【管道文本】【标签内文本】【嵌入大段文本】

4.javascript
	面向对象三个特征： 封装，继承和多态
	事件三个阶段：捕获、目标和冒泡
	事件冒泡：绑定的事件从最里层的元素开始触发，然后冒泡到最外层(addEventListener('click', fn, false))
	事件捕获：绑定的事件从最外层的元素开始触发，然后传到最里层(addEventListener('click', fn, true))
    1)事件委托：一般是无法给新创建的元素绑定事件，此时利用冒泡的特性，采用事件委托
    原理：1.冒泡   2.dom的遍历
     click，mousedown，mouseup，keydown，keyup，keypress适合用事件委托
     mouseover和mouseout不太适合，因为需要计算位置，focus，blur没有冒泡性不能用
    优点：减少事件注册，节省内存；简化了dom节点更新时，相应事件的更新
    2)闭包：简单说一个函数引用另一个函数的变量  可以理解成定义在一个函数内部的函数
    特点：可获取函数内部的变量，也可将这些变量一直保存在内存中
	dom0级事件 比如onclick事件， 多个事件只会执行最后一个；dom2级 addEventListener事件，多个事件按顺序依次往下执行

5.cookie和token   存储web页面的用户信息
	因为http是没有状态的，所以需要一个标志来对用户身份进行验证
	举例：cookie是服务员看你身份证后，给一个编号，此后只需展示这个编号然后服务员根据该编号查找
		token: 每次都是直接展示身份证给服务员查看

异步意味着该函数的执行不会阻塞后面代码的执行
1.Promise
	1)Promise.all()成功了返回一个由所有请求返回值组成的数据，失败了就返回失败的这个请求的返回值
	2)Promise.race()类似赛跑一样，只有请求最快的才会被后面的.then处理
	3)Promise.resolve()能将现有对象转为 Promise 对象
	4)Promise.reject() 会直接返回rejected状态的Promise

2.async/await
    1)async返回的是一个Promise对象，需要用.then和.catch方法来获取返回值
    2)await等待，只能放在async里面

3.模块化思想(AMD, CMD, ESM)
	1)AMD: 使用 define 定义模块，使用 require 加载模块(依赖前置, 提前执行)(RequireJS)
	2)common.js: module.exports暴露模块接口， require引入模块(同步执行)
	3)CMD: 尽量懒执行(Sea.js)

4.几种请求方式
	http是一个非状态性，每次都要重新传输数据
 	1)短轮询：每隔一段时间发送请求，要求服务端即时反应(1个request对应1个response)
 	2)长轮询：不要服务端即时反应，服务端会返回超时或者有效数据，客户端得到后再发请求(1个request对应1个response)（缺点：需要有很高的并发，也就是说同时接待客户的能力）
 	3)流技术：基于 Iframe 及 htmlfile 的流(http streaming)方式，保持长连接，服务端可以不停的返回数据(1个request对应多个response))
 	5)ajax轮询：每隔几秒会发请求询问服务器（缺点： 需要服务器有很快的处理速度和资源）
 	4)websocket: 全双工通信
 		服务端可以主动推送信息给客户端

5.跨域(jsonp, proxy, CORS)(协议，域名，端口不同)
	1)原因：浏览器的同源策略，针对接口请求和dom查询
	2)jsonp: 只能发get请求,一些特殊标签不存在跨域，比如script,img,link等,jsonp利用script的src来实现跨域，
	jquery封装了jsonp, $.ajax的dataType属性设为'jsonp' ===> $.getJSON(url,data,success(data,status,xhr))
	3)CORS：支持所有类型的请求 W3C为浏览器制定的可以跨域通信的规范，分简单请求和非简单请求两个 ie浏览器不能低于ie10
	4)proxy: 服务器代理

6.事件监听
	onclick: 元素绑定多个事件时，只有最后一个会起作用
	attachEvent: 绑定多个事件时，从后往前一一执行 （在ie浏览器使用） 会在全局左右域中运行，this指向window
	addEventListener: element.addEventListener(click, function() {}, false)绑定多个事件时，若第三个值为false则从内往外执行，反之从外往内执行 （在非ie浏览器使用）在依附元素的作用域中运行

7.http协议
  状态码： 1xx 提示信息：表示请求已被成功接收，继续处理     2xx： 请求成功
  		   3xx： 重定向 要完成请求必须要进行进一步的处理
  		   4xx： 客户端错误     5xx： 服务端错误
  cookies将状态保存在客户端，session将状态保存在服务端

8.ifram
